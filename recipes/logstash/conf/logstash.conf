input {
    intercom {
        # Configure your Intercom API credentials
        app_id => ':app_id'
        app_api_key => ':app_api_key'

        # True to sync all users from Intercom
        sync_users => true

        # True to sync all events from Intercom
        sync_events => true
    }
}

filter {

    # Process event of type "user"
    if [type] == "user" {

        # We anonymize the user data because we do not
        # care about this in an analytics context
        anonymize {
            key => "1fb67bacdf039f44c1d7282e682922b0"
            fields => [
                "user_email"
            ]
        }

        # Populate geoip field using location_data infos
        ruby {
            code => "
                longitude = event['user_location_data_longitude']
                latitude = event['user_location_data_latitude']
                unless longitude.is_nil? or latitude.is_nil?
                    event['geoip'] = {
                      'location' => [ longitude, latitude ],
                      'longitude' => longitude,
                      'latitude' => latitude
                    }
                end
            "
        }

        mutate {
            remove_field => [
                "user_pseudonym",       # unnecessary for analytics
                "user_name",            # unnecessary for analytics
                "user_tags",            # unusable like this
                "user_segments",        # unusable like this
                "user_social_profiles", # unusable like this
                "user_companies",       # unusable like this
                "user_location_data_longitude", # moved to geoip
                "user_location_data_latitude"   # moved to geoip
            ]

            rename => {
                "user_location_data_timezone" => "user_timezone"
                "user_location_data_longitude" => "user_longitude"
                "user_location_data_region_name" => "user_region_name"
                "user_location_data_continent_code" => "user_continent_code"
                "user_location_data_city_name" => "user_city_name"
                "user_location_data_postal_code" => "user_postal_code"
                "user_location_data_country_name" => "user_country_name"
                "user_location_data_latitude" => "user_latitude"
                "user_location_data_country_code" => "user_country_code"
            }
        }

        # Convert timestamp to Elasticsearch friendly format
        date {
            match => [ 'user_created_at', 'UNIX' ]
            target => 'user_created_at'
        }
        date {
            match => [ 'user_remote_created_at', 'UNIX' ]
            target => 'user_remote_created_at'
        }
        date {
            match => [ 'user_updated_at', 'UNIX' ]
            target => 'user_updated_at'
        }
        date {
            match => [ 'user_signed_up_at', 'UNIX' ]
            target => 'user_signed_up_at'
        }
        date {
            match => [ 'user_last_request_at', 'UNIX' ]
            target => 'user_last_request_at'
        }
    }

    # Process event of type "event"
    if [type] == "event" {

        # We anonymize the user data because we do not
        # care about this in an analytics context
        anonymize {
            key => "1fb67bacdf039f44c1d7282e682922b0"
            fields => [
                "event_email"
            ]
        }

        # Convert timestamp to Elasticsearch friendly format
        date {
            match => [ 'event_created_at', 'UNIX' ]
            target => 'event_created_at'
        }

        # We drop unnecessary fields for analytics
        mutate {
            remove_field => [
                "event_id"
            ]
        }
    }

}

output {
    if [loglevel] == "debug" {
        stdout { codec => rubydebug }
    } else {
        elasticsearch {
            hosts => ["elasticsearch"]
            index => "logstash-%{+YYYY.MM}"
        }
    }
}
